{"meta":{"title":"我的地盘我做主","subtitle":null,"description":null,"author":"Gecko5","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Angular作用域/自定义指令","slug":"Angular作用域-自定义指令","date":"2017-05-10T02:58:17.000Z","updated":"2017-05-10T03:23:18.433Z","comments":true,"path":"2017/05/10/Angular作用域-自定义指令/","link":"","permalink":"http://yoursite.com/2017/05/10/Angular作用域-自定义指令/","excerpt":"控制器作用域 控制器和函数一样,也有自己的作用域.类似函数,作用域范围内先自己自身找,自己有就用自己的,自己没有的话会向上查找,找父控制器. 子级可以访问父级元素,父级元素不能访问子级元素 每个控制器(controller)都对应一个模型(Model),也就是($scope)对象,不同层级控制器下的$scope便产生了作用域. 模块之间是不可以嵌套使用的 但是控制器之间是可以嵌套使用的 使用ng-init 定义全局作用域。范围是整个模块。$rootScope 示例代码: 函数作用域","text":"控制器作用域 控制器和函数一样,也有自己的作用域.类似函数,作用域范围内先自己自身找,自己有就用自己的,自己没有的话会向上查找,找父控制器. 子级可以访问父级元素,父级元素不能访问子级元素 每个控制器(controller)都对应一个模型(Model),也就是($scope)对象,不同层级控制器下的$scope便产生了作用域. 模块之间是不可以嵌套使用的 但是控制器之间是可以嵌套使用的 使用ng-init 定义全局作用域。范围是整个模块。$rootScope 示例代码: 函数作用域 1234567891011&lt;script&gt; var a = 10; function test() &#123; var a = 20; var b = 10; &#125; //alert(a); test(); //子级可以访问父级的作用域。 //父级不能访问子级的作用域。&lt;/script&gt; 示例代码:控制器作用域 12345678910111213141516171819202122// 全局作用域也就是根作用域&lt;body ng-app=&quot;app&quot; ng-init=&quot;name=&apos;eee&apos;&quot;&gt;&lt;div ng-controller=&quot;appController1&quot;&gt; &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;div ng-controller=&quot;appController2&quot;&gt; &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/angular.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module(&apos;app&apos;,[]); app.controller(&apos;appController1&apos;,[&apos;$scope&apos;,function ($scope) &#123; // 输出eee &#125;]); app.controller(&apos;appController2&apos;,[&apos;$scope&apos;,function ($scope) &#123; // 输出eee &#125;]);&lt;/script&gt;&lt;/body&gt; 自定义指令 AngularJs允许根据实际业务需要自定义指令,通过angular全局对象下的directive方法实现 示例代码 : 1234567891011121314151617181920212223242526272829303132&lt;body ng-app=&quot;app&quot; ng-controller=&quot;appController&quot;&gt;&lt;ele&gt; &lt;ul&gt; &lt;li&gt;我是transclude1&lt;/li&gt; &lt;li&gt;我是transclude2&lt;/li&gt; &lt;li&gt;我是transclude3&lt;/li&gt; &lt;li&gt;我是transclude4&lt;/li&gt; &lt;li&gt;我是transclude5&lt;/li&gt; &lt;/ul&gt;&lt;/ele&gt;&lt;script src=&quot;../js/angular.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module(&apos;app&apos;, []); app.controller(&apos;appController&apos;, [&apos;$scope&apos;, function ($scope) &#123; &#125;]); // 第一个参数:指令名称 // 第二个参数:回调函数 app.directive(&apos;ele&apos;, function () &#123; return &#123; // E:代表元素 A:代表属性 C:当做类 restrict: &apos;EAC&apos;, // 以哪一种形式出现 template: &quot;&lt;div&gt;&lt;h1&gt;自定义指令&lt;/h1&gt; &lt;p&gt;p标签&lt;/p&gt; &lt;div&gt;232222222&lt;/div&gt;&lt;/div&gt;&quot;, replace: true, //是否替换原标签 //如果要替换整个标签 需要一个大标签把自定义的标签包裹起来 transclude: false // 是否保留原标签的内容 &#125; &#125;);&lt;/script&gt;&lt;/body&gt; 模版命令 示例代码 : 1234567891011// 上面的代码都一样 就是需要自定义一个html文件,然后引入 方便管理app.directive(&apos;ele&apos;, function () &#123; return &#123; // E:代表元素 A:代表属性 C:当做类 restrict: &apos;EA&apos;, // 以哪一种形式出现 templateUrl: &quot;./ele.html&quot;, replace: true, //是否替换原标签 transclude: true // 是否保留原标签的内容 &#125; &#125;); 过滤器 AngularJs内置9个过滤器 过滤器的本质就是函数 管道符 上次的结果作为下一次的参数传递 示例代码 : 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 1.currency默认是美元符号 也可以自定义符号 currency:将数值转化为货币格式--&gt;&lt;p&gt;&#123;&#123;price | currency:&apos;&amp;yen&apos;&#125;&#125;&lt;/p&gt;&lt;!--2.日期格式化 年(y) 月(M) 日(d) 星期(EEEE/EEE) 时(H/h) 分(mm) 秒(ss) 毫秒(sss)--&gt;&lt;p&gt;&#123;&#123;dateTime | date:&apos;yyyy-MM-dd hh:mm:ss&apos;&#125;&#125;&lt;/p&gt;&lt;!--3.filter:在给定数组中选择满足条件的一个子集,并返回一个新数组,其条件可以是字符串\\对象\\函数--&gt;&lt;p&gt;&#123;&#123;course | filter:&apos;j&apos;&#125;&#125;&lt;/p&gt;&lt;!--4.limitTo:取出字符串或者数组的的前几位(正数)或者后几位(负数)--&gt;&lt;p&gt;&#123;&#123;course | limitTo:-2&#125;&#125;&lt;/p&gt;&lt;!--5.uppercase:把文本转换成大写lowercase: 把文本转成小写--&gt;&lt;p&gt;&#123;&#123;name | uppercase | lowercase&#125;&#125;&lt;/p&gt;&lt;!--6.numStr:在number当中不能出现非数字--&gt;&lt;p&gt;&#123;&#123;numStr | number:4&#125;&#125;&lt;/p&gt;&lt;!--7.orderBy:排序true降序 false升序--&gt;&lt;p&gt;&#123;&#123;scores | orderBy:&apos;&apos;:false&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;scores | orderBy:&apos;score&apos;:true&#125;&#125;&lt;/p&gt;&lt;!--8.取出所有的数据--&gt;&lt;p&gt;&#123;&#123;stus&#125;&#125;&lt;/p&gt;&lt;!--9.json 也是取出数据--&gt;&lt;p&gt;&#123;&#123;stus | json&#125;&#125;&lt;/p&gt; 12345678910111213141516171819202122232425262728&lt;script src=&quot;../js/angular.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module(&apos;app&apos;, []); app.controller(&apos;appController&apos;, [&apos;$scope&apos;, function ($scope) &#123; // price $scope.price = &quot;18&quot;; // 日期 $scope.dateTime = new Date(); // 数组 $scope.course = [&apos;ios&apos;,&apos;html&apos;,&apos;java&apos;,&apos;ui&apos;]; $scope.course = [100,30,40,20,4]; // 大小写转化 $scope.name = &apos;LENG&apos; /* 实现原理 * parseInt() 直到遇到非数字才停止 * number:里面不允许出非数字。 * */ $scope.numStr = &apos;18&apos;; // 排序 $scope.scores = [100,30,40,20,4]; $scope.stus = [ &#123;name:&apos;zs&apos;,score:20&#125;, &#123;name:&apos;wc&apos;,score:90&#125;, &#123;name:&apos;ls&apos;,score:59&#125; ] &#125;]);&lt;/script&gt; 自定义过滤器 AngularJs内置过滤器外,还可以根据业务需要自定义过滤器通过模块对象实例提供的filter方法自定义过滤器 示例代码 : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;body ng-app=&quot;app&quot; ng-controller=&quot;appController&quot;&gt;&lt;p&gt;&#123;&#123;price | eFilter:&apos;eFilter&apos;&#125;&#125;&lt;/p&gt;&lt;!-- 需求:把第一个字符变成大写 --&gt;&lt;p&gt;&#123;&#123;name | eeUppercase&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;price | eeCurrent : &apos;&amp;&apos;&#125;&#125;&lt;/p&gt;&lt;script src=&quot;../js/angular.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module(&apos;app&apos;, []); app.controller(&apos;appController&apos;, [&apos;$scope&apos;, function ($scope) &#123; $scope.price = &apos;18.8&apos;; $scope.name = &apos;ee&apos;; &#125;]); // 自定义指令 app.directive(&apos;ee&apos;, function () &#123; return &#123; restrict: &quot;ECA&quot;, template: &quot;&lt;h1&gt;ee&lt;/h1&gt;&quot;, replace: true &#125; &#125;); /*过滤器的本质就是一个function * 第一个参数:过滤器的名称 第二个参数:回调函数 * input 就是管道符前面执行的结果 * 返回值为一个函数 * */ app.filter(&apos;eFilter&apos;, function () &#123; return function (input, args) &#123; console.log(input + args); &#125; &#125;); angular.module(&apos;app&apos;).filter(&apos;eeUppercase&apos;,function () &#123; return function (input) &#123; var str = input[0].toUpperCase() + input.slice(1); return str; &#125; &#125;); app.filter(&apos;eeCurrent&apos;,function () &#123; return function (input, args) &#123; if(args)&#123; return args + input; &#125; else &#123; return + &apos;$&apos; + input; &#125; &#125; &#125;); // 打印结果 Ee &amp;18.8&lt;/script&gt;&lt;/body&gt; 依赖注入 AngularJS采用模块化的方式组织代码，将一些通用逻辑封装成一个对象或函数，实现最大程度的复用这导致了使用者和被使用者之间存在依赖关系。 所谓依赖注入是指在运行时自动查找依赖关系 然后将查找到依赖传递给使用者的一种机制。 依赖注入为分两种: 行内式注入以数组形式明确声明依赖，数组元素都是包含依赖名称的字符串，数组最后一个元素是依赖注入的目标函数推荐使用行内式注入. 推断式注入没有明确声明依赖，AngularJS会将函数参数名称当成是依赖的名称这种方式会带来一个问题，当代码经过压缩后函数的参数被压缩，这样便会造成依赖无法找到。 示例代码 : 123456789101112131415161718192021222324252627&lt;body ng-app=&quot;app&quot; ng-controller=&quot;xiController&quot;&gt;&lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;script src=&quot;../js/angular.js&quot;&gt;&lt;/script&gt;&lt;script&gt; /* * 1.什么是服务？ * 服务就是angular内置的一些功能。直接拿到该功能做一些事情。 * 2.依赖注入？ * 模块当中依赖系统的哪些功能（用到系统-&gt;angular默认的哪些功能） * 查找该功能，找到之后， 系统会对应的功能，传递给指定的模块。这个过程，依赖注入。 * 行内式注入 * 推断式注入 * */ var app = angular.module(&apos;app&apos;,[]); // 行内式注入 -- 推荐使用行内式注入 app.controller(&apos;appController&apos;,[&apos;$scope&apos;,function ($scope) &#123; $scope.name = &apos;行内式注入&apos;; &#125;]); // 推断式注入 -- 当代码被压缩时 参数就不会被找到 app.controller(&apos;xiController&apos;,function ($scope) &#123; $scope.name = &apos;推断式注入&apos; &#125;);&lt;/script&gt;&lt;/body&gt; $location服务 服务就angular内置的功能 它的本质就是一个对象或函数 $location是对原生Javascript中location对象属性和方法的封装。 示例代码 : 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body ng-app=&quot;app&quot; ng-controller=&quot;appController&quot;&gt;&lt;!-- https://www.baidu.com/?tn=93912046_hao_pg https:协议 主机地址:www.baidu.com 192.52.6.74 端口号：63342/8080 /code/06-$location服务.html :文件路径 ？name=xmg&amp;age=10 : 传递的参数 #/test/ 锚点 hash值。--&gt;&lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;absUrl&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;hostName&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;url&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;search&#125;&#125;&lt;/p&gt;&lt;script&gt; // js原生网络地址 for (var key in location) &#123; console.log(key + &apos;------&apos; + location[key]); &#125;&lt;/script&gt;&lt;script src=&quot;../js/angular.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module(&apos;app&apos;, []); app.controller(&apos;appController&apos;, [&apos;$scope&apos;, &apos;$location&apos;, function ($scope, $location) &#123; $scope.name = &apos;xibalu&apos;; // 获取当前地址 $scope.absUrl = $location.absUrl(); // 获取主机名 $scope.hostName = $location.host(); // 获取锚点后面的地址 $scope.url = $location.url(); // 获得第二个锚点之后的地址 $scope.hash = $location.hash(); // 单页面应用程序 锚点搜索 $scope.search = $location.search(); &#125;]);&lt;/script&gt;&lt;/body&gt; 定时器服务 $timeout&amp;$interval对原生Javascript中的setTimeout和setInterval进行了封装。 示例代码 : 123456789101112131415161718192021222324252627282930&lt;body ng-app=&quot;app&quot; ng-controller=&quot;appController&quot;&gt;&lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;timeDate | date:&apos;yyyy-MM-dd hh:mm:ss&apos;&#125;&#125;&lt;/p&gt;&lt;input type=&quot;button&quot; value=&quot;点击停止&quot; ng-click=&quot;stop()&quot;&gt;&lt;script src=&quot;../js/angular.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module(&apos;app&apos;, []); app.controller(&apos;appController&apos;, [&apos;$scope&apos;, &apos;$timeout&apos;, &apos;$interval&apos;, function ($scope, $timeout, $interval) &#123; // 一次定时器 $timeout(function () &#123; $scope.name = &apos;xiba&apos;; &#125;, 2000); // 多次定时器 var timer = $interval(function () &#123; $scope.timeDate = new Date(); &#125;,1000); /*如何停止定时器 * 通过变量保存。 * $interval.cancel(timer); * */ $scope.stop = function () &#123; $interval.cancel(timer); &#125; &#125;]);&lt;/script&gt;&lt;/body&gt;","categories":[],"tags":[]},{"title":"Angular基本属性/功能","slug":"Angular基本属性-功能","date":"2017-05-10T02:27:33.000Z","updated":"2017-05-10T02:48:36.018Z","comments":true,"path":"2017/05/10/Angular基本属性-功能/","link":"","permalink":"http://yoursite.com/2017/05/10/Angular基本属性-功能/","excerpt":"什么是AngularJsAngularJS是一款由Google公司开发维护的前端MVC框架，其克服了HTML在构建应用上的诸多不足，从而降低了开发成本提升了开发效率。","text":"什么是AngularJsAngularJS是一款由Google公司开发维护的前端MVC框架，其克服了HTML在构建应用上的诸多不足，从而降低了开发成本提升了开发效率。AngularJS与我们之前学习的jQuery是有一定的区别的，jQuery更准确来说只一个类库（类库指的是一系列函数的集合）以DOM做为驱动（核心），而AngularJS则一个框架（诸多类库的集合）以数据和逻辑做为驱动（核心）。框架对开发的流程和模式做了约束，开发者遵照约束进行开发，更注重的实际的业务逻辑。 AngularJS特性核心模块化双向数据绑定语义化标签依赖注入等 Angular下载方式官网下载 直接点击跳转通过npm下载命令为:npm install angular 通过bower下载命令为:bower install angular MVVM模式图解 MVCMVC是一种开发模式，由模型（Model）、视图（View）、控制器（Controller）3部分构成.用一种业务逻辑,数据,界面显示分离的方法组织代码,将业务逻辑聚集到一个部件里面.在改进和个性化定制界面及用户交互的同时不需要重新编写业务逻辑. 采用这种开发模式为合理组织代码提供了方便、降低了代码间的耦合度、功能结构清晰可见。 M模型（Model）一般用来处理数据（读取/设置），一般指操作数据库。 V视图（View）一般用来展示数据，比如通过HTML展示。C控制器（Controller）一般用做连接模型和视图的桥梁。 MVC更多应用在后端开发程序里，后被引入到前端开发中，由于受到前端技术的限制便有了一些细节的调整，进而出现了很多MVC的衍生版（子集）如MVVM、MVW、MVP、MV*等。 图解 Angular基本步骤 如果你发现自己写的代码没有任何反应那就说明,你可能是没有绑定模块和控制器 示例代码: 1234567891011121314151617// 1.导入文件 &lt;script src=&quot;js/angular.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 2.创建模块 var app = angular.module(&apos;app&apos;, []); // 3.创建控制器 app.controller(&apos;myController&apos;, [&apos;$scope&apos;, function ($scope) &#123; $scope.name = &apos;aaa&apos;; $scope.age = 10; &#125;]);&lt;/script&gt;&lt;!-- 4.绑定模块 --&gt;&lt;body ng-app=&quot;app&quot;&gt; &lt;!-- 5.绑定控制器 --&gt; &lt;input type=&quot;text&quot; ng-model=&quot;msg&quot;&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&lt;/body&gt; 内置指令 HTML在构建应用（App）时存在诸多不足之处，AngularJS通过扩展一系列的HTML属性或标签来弥补这些缺陷，所谓指令就是AngularJS自定义的HTML属性或标签，这些指令都是以ng-做为前缀的，例如ng-app、ng-controller、ng-repeat等。 示例代码: &lt; ! ———- HTML ———– &gt; 1234567891011121314151617181920212223242526272829303132333435// 一般模块和控制器都绑定给body,实际开发中根据需求来&lt;body ng-app=&quot;app&quot; ng-controller=&quot;dataController&quot;&gt; &lt;!-- ng-show 控制标签是否显示隐藏 --&gt; // 标签依然存在在页面 只是隐藏 相当于给它设置了display为none // 1.第一种写法 &lt;p ng-show=&quot;isShow&quot;&gt;isShow 控制标签是否显示&lt;/p&gt; // 2.第二种写法 &lt;p ng-show=&quot;false&quot;&gt;isShow 控制标签是否显示&lt;/p&gt; &lt;!-- ng-hide 控制标签是否显示隐藏 --&gt; &lt;!--标签依然存在在页面 只是隐藏 相当于给它设置了display为none --&gt; &lt;p ng-hide=&quot;false&quot;&gt;isShow 控制标签是否显示&lt;/p&gt; &lt;!-- ng-if 控制标签是否存在 取值布尔值 --&gt; &lt;!-- 标签不会存在在页面 相当于注释掉了 --&gt; &lt;p ng-if=&quot;false&quot;&gt;ng-if 控制标签是否存在&lt;/p&gt; &lt;!-- img ng-src 不发送请求 回头再执行一次 img src 执行时 会现发送请求 如果路径里面写的是ng的值 就是出现404报错信息 img ng-src 不会先发送请求 会回头再来执行一次路径 &#123;&#123; 两个大括号是插值语法 &#125;&#125; --&gt; ![](&#123;&#123;path&#125;&#125;) ![](&#123;&#123;path&#125;&#125;) &lt;!-- ng-class ng-style 控制样式 --&gt; &lt;p ng-class=&quot;&#123;red:isRed,fz50:true&#125;&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p ng-style=&quot;ctrSty&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;&lt;/body&gt; &lt; ! ——— Style ————— &gt; 12345678910&lt;style&gt; .red &#123; color: goldenrod; &#125; .fz50 &#123; font-size: 50px; &#125;&lt;/style&gt; &lt; ! ——— JavaScript ——- &gt; 12345678910111213141516&lt;script src=&quot;js/angular.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module(&apos;app&apos;, []); app.controller(&apos;dataController&apos;, [&apos;$scope&apos;, function ($scope) &#123; $scope.name = &apos;惊鸿一样短暂,夏花一样绚丽&apos;; // 在模型上绑定数据 1为真 0为假 也可以写成true或者false $scope.isShow = 1; // 插入图片 $scope.path = &apos;atom-transfer.gif&apos;; // 控制样式 $scope.isRed = 1; $scope.ctrSty = &#123; color: &apos;red&apos;, &#125; &#125;]);&lt;/script&gt; ng-include ng-include:开发中我们需要把一个模块单独写到一个页面当中,以便复用原生HTMl是没法办到的,一般需要通过服务器来完成这个功能本质是发送了一个Ajax请求 把请求的结果放到对应的标签里面 示例代码: 1234567891011// 同级目录下需要创建head\\body\\footer的html文件引入才行&lt;div ng-include=&quot;&apos;./04-head.html&apos;&quot;&gt;&lt;/div&gt;&lt;div ng-include=&quot;&apos;./04-body.html&apos;&quot;&gt;&lt;/div&gt;&lt;div ng-include=&quot;&apos;./04-footer.html&apos;&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/angular.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module(&apos;app&apos;,[]); app.controller(&apos;dataController&apos;,[&apos;$scope&apos;,function ($scope) &#123; &#125;]);&lt;/script&gt; 图解 —&gt; 你会发现在页面上多了三个复用模块 表单指令 示例代码:&lt; ! ———- HTML ———– &gt; 12345678&lt;!-- ng-disabled 控制表单是否可用 --&gt;&lt;input type=&quot;text&quot; ng-disabled=&quot;true&quot;&gt;&lt;!-- ng-readonly 控制表单为只读属性 --&gt;&lt;input type=&quot;text&quot; value=&quot;默认值&quot; ng-readonly=&quot;true&quot;&gt;&lt;!-- ng-checked 设置复选框选中状态 --&gt;&lt;input type=&quot;checkbox&quot; ng-checked=&quot;isCheck&quot;&gt; &lt; ! ——— JavaScript ——- &gt; 1234567&lt;script src=&quot;js/angular.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module(&apos;app&apos;, []); app.controller(&apos;dataController&apos;, [&apos;$scope&apos;, function ($scope) &#123; $scope.isCheck = true; &#125;]);&lt;/script&gt; ng-switch指令 示例代码: 123456789101112131415161718192021&lt;body ng-app=&quot;app&quot; ng-controller=&quot;dataController&quot;&gt;&lt;ul&gt; &lt;!-- 遍历 ng-repeat 筛选对象 匹配就显示 否则隐藏 ng-switch-when --&gt; &lt;li ng-repeat=&quot;value in course&quot; ng-switch=&quot;value&quot;&gt; &lt;!-- 对&#123;&#123;value&#125;&#125;进行判断 when就是条件 满足就显示 否则隐藏 --&gt; &lt;p ng-switch-when=&quot;html&quot;&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;js/angular.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module(&apos;app&apos;, []); app.controller(&apos;dataController&apos;, [&apos;$scope&apos;, function ($scope) &#123; $scope.course = [&apos;html&apos;, &apos;css&apos;, &apos;js&apos;]; &#125;]);&lt;/script&gt;&lt;/body&gt; 数据单向绑定 单向数据绑定是指将模型（Model）数据，按着写好的视图（View）模板生成HTML标签，然后追加到DOM中显示，如之前所学的artTemplate 模板引擎的工作方式。 1234567891011121314151617181920212223242526272829&lt;body ng-app=&quot;app&quot; ng-controller=&quot;dataController&quot;&gt;&lt;ul&gt; &lt;!-- 把模型的数据 展示到视图当中 1.加载时会造成闪烁 解决办法 使用ng-cloak 但是还是会闪烁,所以不建议使用这种 --&gt; &lt;li ng-cloak&gt;&#123;&#123;name&#125;&#125;&#123;&#123;age&#125;&#125;&lt;/li&gt; &lt;!-- 2.使用ng-bind 不会造成闪烁 但是只可以绑定一个值 --&gt; &lt;&lt;li ng-bind=&quot;name&quot;&gt;&lt;/li&gt; &lt;!-- 3.使用ng-bind-template 不会造成闪烁 可以绑定多个值 --&gt; &lt;li ng-bind-template=&quot;&#123;&#123;name&#125;&#125; &#123;&#123;age&#125;&#125;&quot;&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;js/angular.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module(&apos;app&apos;,[]); app.controller(&apos;dataController&apos;,[&apos;$scope&apos;,function ($scope) &#123; $scope.name = &apos;xxxxxxxxxxxxxxxxx&apos;; $scope.age = 2000000000000000000; &#125;]);&lt;/script&gt;&lt;/body&gt; 数据双向绑定 数据双向绑定：模型中的数据可以绑定到视图中视图中的数据也可以绑定到模型中 想要将视图的数据绑定到模型当中 必须借助表单标签 123456789101112131415161718192021222324252627&lt;body ng-app=&quot;app&quot; ng-controller=&quot;dataController&quot;&gt;&lt;!-- 模型的数据绑定到视图当中 用ng-bind &lt;h1 ng-bind=&quot;name&quot;&gt;&lt;/h1&gt;--&gt;&lt;!-- 视图绑定到模型 借助表单 绑定ng-model --&gt;&lt;input type=&quot;text&quot; ng-model=&quot;userName&quot;&gt;&lt;input type=&quot;password&quot; ng-model=&quot;pwd&quot;&gt;&lt;!-- 监听点击按钮时 实现绑定 --&gt;&lt;button ng-click=&quot;login()&quot;&gt;登录&lt;/button&gt;&lt;script src=&quot;js/angular.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module(&apos;app&apos;, []); app.controller(&apos;dataController&apos;, [&apos;$scope&apos;, function ($scope) &#123; // 模型当中定义name属性 $scope.name = &apos;登录&apos; // 事件绑定 $scope.login = function () &#123; // 点击时可以直接打印视图绑定到模型当中的数据 console.log($scope.userName + &apos;---------&apos; + $scope.pwd); &#125; &#125;]);&lt;/script&gt;&lt;/body&gt; 事件处理123456789101112131415161718192021222324252627282930&lt;body ng-app=&quot;app&quot; ng-controller=&quot;dataController&quot;&gt;&lt;!-- 单击事件 ng-click=&quot;click($event,p)&quot;--&gt;&lt;button ng-click=&quot;click()&quot;&gt;点我&lt;/button&gt;&lt;!-- 双击事件 ng-dbclick=&quot;dbclick(&apos;dbl)&quot;--&gt;&lt;button ng-dblclick=&quot;dblclick()&quot;&gt;双击&lt;/button&gt;&lt;!-- 鼠标移入 ng-mouseEnter=&quot;mouseEnter(&apos;进入&apos;)&quot;--&gt;&lt;button ng-mouseenter=&quot;mouseEnter()&quot;&gt;进入&lt;/button&gt;&lt;script src=&quot;js/angular.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module(&apos;app&apos;,[]); app.controller(&apos;dataController&apos;,[&apos;$scope&apos;,function ($scope) &#123; $scope.click = function () &#123; console.log(&apos;单击&apos;); &#125; $scope.dblclick = function () &#123; console.log(&apos;双击&apos;); &#125; $scope.mouseEnter = function () &#123; console.log(&apos;鼠标进入&apos;); &#125; &#125;]);&lt;/script&gt;&lt;/body&gt;","categories":[],"tags":[]},{"title":"浅析前端页面渲染机制","slug":"浅析前端页面渲染机制","date":"2017-05-09T14:06:34.000Z","updated":"2017-05-09T14:51:12.750Z","comments":true,"path":"2017/05/09/浅析前端页面渲染机制/","link":"","permalink":"http://yoursite.com/2017/05/09/浅析前端页面渲染机制/","excerpt":"作为一个前端开发，最常见的运行环境应该是浏览器吧，为了更好的通过浏览器把优秀的产品带给用户，也为了更好的发展自己的前端职业之路，有必要了解从我们在浏览器地址栏输入网址到看到页面这期间浏览器是如何进行工作的,进而了解如何更好的优化实践，本篇主要围绕这两点展开阐述。前端页面渲染机制可谓是老生常谈，但又很有必要再谈的话题，于是还是决定写一篇，即是对知识的回顾总结，又能与大家分享，何乐而不为。网上相关类型的文章也很多，有兴趣的可以多学习一下。","text":"作为一个前端开发，最常见的运行环境应该是浏览器吧，为了更好的通过浏览器把优秀的产品带给用户，也为了更好的发展自己的前端职业之路，有必要了解从我们在浏览器地址栏输入网址到看到页面这期间浏览器是如何进行工作的,进而了解如何更好的优化实践，本篇主要围绕这两点展开阐述。前端页面渲染机制可谓是老生常谈，但又很有必要再谈的话题，于是还是决定写一篇，即是对知识的回顾总结，又能与大家分享，何乐而不为。网上相关类型的文章也很多，有兴趣的可以多学习一下。 浏览器在介绍浏览器工作流程之前，先了解一下主流浏览器的基础结构，本文所介绍的浏览器主要为开源的Chrome，FireFox及部分开源的Safari，这也是目前市场占比最高的几大浏览器，以本人博客网站为例，可以大致看出各浏览器使用比例： 浏览器基础结构浏览器基础结构主要包括如下7部分： 1.用户界面（User Interface）:用户所看到及与之交互的功能组件，如地址栏，返回，前进按钮等； 2.浏览器引擎（Browser engine）:负责控制和管理下一级的渲染引擎； 3.渲染引擎（Rendering engine）:负责解析用户请求的内容（如HTML或XML，渲染引擎会解析HTML或XML，以及相关CSS，然后返回解析后的内容）； 4.网络（Networking）:负责处理网络相关的事务，如HTTP请求等； 5.UI后端（UI backend）:负责绘制提示框等浏览器组件，其底层使用的是操作系统的用户接口； 6.JavaScript解释器（JavaScript interpreter）:负责解析和执行JavaScript代码； 7.数据存储（Data storage）:负责持久存储诸如cookie和缓存等应用数据。 浏览器内核各大主要浏览器使用内核也是有差别的，大致可以分为以下几类： Trident内核： IEWebkit内核：Chrome,SafariGecko内核：FireFox 网络当用户访问页面时，浏览器需要获取用户请求内容，这个过程主要涉及浏览器网络模块： 1.用户在地址栏输入域名，如baidu.com，DNS（Domain Name System，域名解析系统）服务器根据输入的域名查找对应IP，然后向该IP地址发起请求； 2.浏览器获得并解析服务器的返回内容(HTTP response)； 3.浏览器加载HTML文件及文件内包含的外部引用文件及图片，多媒体等资源。 DNS预解析（DNS prefetch）浏览器DNS解析大多时候较快，且会缓存常用域名的解析值，但是如果网站涉及多域名，在对每一个域名访问时都需要先解析出IP地址，而我们希望在跳转或者请求其他域名资源时尽量快，则可以开启域名预解析，浏览器会在空闲时提前解析声明需要预解析的 多进程我们通常说JavaScript执行是单进程的，但是浏览器网络部分通常是有几个平行进程同时开启，但是也会有限制，一般为2-6个。 渲染引擎及关键渲染路径（Critical Rendering Path）渲染引擎所做的事是将请求内容展现给我们，默认支持HTML,XML和图片类型，对于其他诸如PDF等类型的内容则需要安装相应插件，但浏览器的展示工作流程基本是一样的。 通过网络模块加载到HTML文件后渲染引擎渲染流程如下，这也通常被称作关键渲染路径（Critical Rendering Path）： 1.构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）； 2.构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树； 3.执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）； 4.构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree)； 渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。 5.布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置； 6.绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成； 为了更友好的用户体验，浏览器会尽可能快的展现内容，而不会等到文档所有内容到达才开始解析和构建/布局渲染树，而是每次处理一部分，并展现在屏幕上，这也是为什么我们经常可以看到页面加载的时候内容是从上到下一点一点展现的。 流程图Webkit渲染引擎流程如下图： Gecko渲染引擎流程如下图： 如上图，Webkit浏览器和Gecko浏览器渲染流程大致相同,不同的是： 1.Webkit浏览器中的渲染树(render tree)，在Gecko浏览器中对应的则是框架树（frame tree）,渲染对象(render object)对应的是框架（frame）; 2.Webkit中的布局（Layout）过程，在Gecko中称为回流（Reflow）,本质是一样的，后文会解释回流的另一层含义–重新布局； 3.Gecko中HTML和DOM树中间多了一层内容池（Content sink）,可以理解成生成DOM元素的工厂。 单进程不同于网络部分的多进程渲染引擎是单线程工作的，意味着渲染流程是一步一步渐进完成的。 解析文档(parser HTML)在详细介绍浏览器渲染文档之前，先应该理解浏览器如何解析文档：解析文档的顺序，对于CSS和JavaScript如何处理等。 解析顺序浏览器按从上到下的顺序扫描解析文档；解析样式和脚本 脚本 或许是由于通常会在JavaScript脚本中改变文档DOM结构，于是浏览器以同步方式解析，加载和执行脚本，浏览器在解析文档时，当解析到标签时，会解析其中的脚本（对于外链的JavaScript文件，需要先加载该文件内容，再进行解析），然后立即执行，这整个过程都会阻塞文档解析，直到脚本执行完才会继续解析文档。就是说由于脚本是同步加载和执行的，它会阻塞文档解析，这也解释了为什么现在通常建议将标签放在标签前面，而不是放在标签里。现在HTML5提供defer和async两个属性支持延迟和异步加载JavaScript文件，如： 改进 针对上文说的脚本阻塞文档解析，主流浏览器如Chrome和FireFox等都有一些优化，比如在执行脚本时，开启另一个进程解析剩余的文档以找出并加载其他的待下载外部资源（不改变主进程的DOM树，仅优化加载外部资源）。 样式 不同于脚本，浏览器对样式的处理并不会阻塞文档解析，大概是因为样式表并不会改变DOM结构。 样式表与脚本 你可能想问样式是否会阻塞脚本文件的加载执行呢？正常情况是不会的，但是存在一个问题是通常我们会在脚本中请求样式信息，但是在文档解析时，如果样式尚未加载或解析，将会得到错误信息，对于这一问题，FireFox浏览器和Webkit浏览器处理策略不同：当存在有样式文件未被加载和解析时，FireFox浏览器会阻塞所有脚本；而Webkit浏览器只会阻塞操作了改文件内声明的样式属性的脚本。 构建DOM树DOM，即文档对象模型（Document Object Model）**,DOM树，即文档内所有节点构成的一个树形结构。假设浏览器获取返回的如下HTML文档： 12345678910111213&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./theme.css&quot;&gt;&lt;/link&gt; &lt;script src=&quot;./config.js&quot;&gt;&lt;/script&gt; &lt;title&gt;关键渲染路径&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=&quot;title&quot;&gt;关键渲染路径&lt;/h1&gt; &lt;p&gt;关键渲染路径介绍&lt;/p&gt; &lt;footer&gt;@copyright2017&lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; 首先浏览器从上到下依次解析文档构建DOM树，如下： 构建CSSOM树CSSOM，即CSS对象模型（CSS Object Model）**，CSSOM树，与DOM树结构相似，只是另外为每一个节点关联了样式信息。theme.css样式内容如下： 123456789101112html, body &#123; width: 100%; height: 100%; background-color: #fcfcfc; &#125; .title &#123; font-size: 20px; &#125; .footer &#123; font-size: 12px; color: #aaa; &#125; 构建CSSOM树如图： 执行JavaScript上文已经阐述了文档解析时对脚本的处理，我们得知脚本加载，解析和执行会阻塞文档解析，而在特殊情况下样式的加载和解析也会阻塞脚本，所以现在推荐的实践是标签放在标签前面。 构建渲染树(render tree)DOM树和CSSOM树都构建完了，接着浏览器会构建渲染树： 渲染树，代表一个文档的视觉展示，浏览器通过它将文档内容绘制在浏览器窗口，展示给用户，它由按顺序展示在屏幕上的一系列矩形对象组成，这些矩形对象都带有字体，颜色和尺寸，位置等视觉样式属性。对于这些矩对象，FireFox称之为框架（frame）,Webkit浏览器称之为渲染对象（render object, renderer），后文统称为渲染对象。 这里把渲染树节点称为矩形对象，是因为，每一个渲染对象都代表着其对应DOM节点的CSS盒子**,该盒子包含了尺寸，位置等几何信息，同时它指向一个样式对象包含其他视觉样式信息。渲染树与DOM树每一个渲染对象都对应着DOM节点，但是非视觉（隐藏，不占位）DOM元素不会插入渲染树，如元素或声明display: none;的元素，渲染对象与DOM节点不是简单的一对一的关系，一个DOM可以对应一个渲染对象，但一个DOM元素也可能对应多个渲染对象，因为有很多元素不止包含一个CSS盒子，如当文本被折行时，会产生多个行盒，这些行会生成多个渲染对象；又如行内元素同时包含块元素和行内元素，则会创建一个匿名块级盒包含内部行内元素，此时一个DOM对应多个矩形对象（渲染对象）。渲染树及其对应DOM树如图： 图中渲染树viewport即视口，是文档的初始包含块，scroll代表滚动区域，详见CSS之视觉格式化模型(Visual Formatting Model) 渲染树并不会包含显式或隐式地display：none;的标签元素。 布局（Layout）或回流（reflow，relayout）创建渲染树后，下一步就是布局（Layout）,或者叫回流（reflow,relayout），这个过程就是通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸，将其安置在浏览器窗口的正确位置，而有些时候我们会在文档布局完成后对DOM进行修改，这时候可能需要重新进行布局，也可称其为回流，本质上还是一个布局的过程，每一个渲染对象都有一个布局或者回流方法，实现其布局或回流。流（flow）HTML采用的是基于流的方式定位布局，其按照从左到右，从上到下的顺序进行排列，详见CSS定位机制**。全局布局与局部布局 对渲染树的布局可以分为全局和局部的，全局即对整个渲染树进行重新布局，如当我们改变了窗口尺寸或方向或者是修改了根元素的尺寸或者字体大小等；而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。 脏位系统（dirty bit system） 大多数web应用对DOM的操作都是比较频繁，这意味着经常需要对DOM进行布局和回流，而如果仅仅是一些小改变，就触发整个渲染树的回流，这显然是不好的，为了避免这种情况，浏览器使用了脏位系统，只有一个渲染对象改变了或者某渲染对象及其子渲染对象脏位值为”dirty”时，说明需要回流。 表示需要布局的脏位值有两种： “dirty”–自身改变，需要回流 “children are dirty”–子节点改变，需要回流 布局过程 布局是一个从上到下，从外到内进行的递归过程，从根渲染对象，即对应着HTML文档根元素，然后下一级渲染对象，如对应着元素，如此层层递归，依次计算每一个渲染对象的几何信息（位置和尺寸）。 几何信息-位置和尺寸，即相对于窗口的坐标和尺寸，如根渲染对象，其坐标为（0， 0），尺寸即是视口尺寸（浏览器窗口的可视区域）。 每一个渲染对象的布局流程基本如： 1.计算此渲染对象的宽度（width）； 2.遍历此渲染对象的所有子级，依次： 2.1设置子级渲染对象的坐标 2.2判断是否需要触发子渲染对象的布局或回流方法，计算子渲染对象的高度（height） 3.设置此渲染对象的高度：根据子渲染对象的累积高，margin和padding的高度设置其高度； 4.设置此渲染对象脏位值为false。 强制回流 在渲染树布局完成后，再次操作文档，改变文档的内容或结构，或者元素定位时，会触发回流，即需要重新布局，如请求某DOM的”offsetHeight”样式信息等诸多情况： DOM操作，如增加，删除，修改或移动； 变更内容； 激活伪类； 访问或改变某些CSS属性（包括修改样式表或元素类名或使用JavaScript操作等方式）； 浏览器窗口变化（滚动或尺寸变化） 12$(&apos;body&apos;).css(&apos;padding&apos;); // reflow$(&apos;body&apos;)[0].offsetHeight; // relow 有过CSS3动画开发经验的同学可能会有经历，如下入场动画： 123456.slide-left &#123; -webkit-transition: margin-left 1s ease-out; -moz-transition: margin-left 1s ease-out; -o-transition: margin-left 1s ease-out; transition: margin-left 1s ease-out; &#125; 然后执行如下脚本： 1234567var $slide = $(&apos;.slide-left&apos;); $slide.css(&#123; &quot;margin-left&quot;: &quot;100px&quot; &#125;).addClass(&apos;slide-left&apos;); $slide.css(&#123; &quot;margin-left&quot;: &quot;10px&quot; &#125;); 我们会发现并没有效果，为什么呢？因为对margin-left的修改并没有触发回流，元素margin-left值的改变被缓存，如果我们在中间强制触发回流： 123456789var $slide = $(&apos;.slide-left&apos;); $slide.css(&#123; &quot;margin-left&quot;: &quot;100px&quot; &#125;); console.log($slide.css(&apos;padding&apos;); $slide.addClass(&apos;slide-left&apos;); $slide.css(&#123; &quot;margin-left&quot;: &quot;10px&quot; &#125;); 绘制（painting）最后是绘制(paint)阶段或重绘（repaint）阶段，浏览器UI组件将遍历渲染树并调用渲染对象的绘制（paint）方法，将内容展现在屏幕上，也有可能在之后对DOM进行修改，需要重新绘制渲染对象，也就是重绘，绘制和重绘的关系可以参考布局和回流的关系。 全局与局部绘制 与布局相似，绘制也分为全局和局部绘制，即对整个渲染树或某些渲染对象进行绘制。 触发重绘 我们已经知道很多操作可能会触发回流，那么什么时候可能触发重绘呢，通常，当改变元素的视觉样式，如background-color,visibility，margin，padding或字体颜色时会触发全局或局部重绘，如： 12$(&apos;body&apos;).css(&apos;color&apos;, &apos;red&apos;); // repaint$(&apos;body&apos;).css(&apos;margin&apos;, &apos;2px&apos;); // reflow, repaint 页面渲染优化浏览器对上文介绍的关键渲染路径进行了很多优化，针对每一次变化产生尽量少的操作，还有优化判断重新绘制或布局的方式等等。 在改变文档根元素的字体颜色等视觉性信息时，会触发整个文档的重绘，而改变某元素的字体颜色则只触发特定元素的重绘；改变元素的位置信息会同时触发此元素（可能还包括其兄弟元素或子级元素）的布局和重绘。某些重大改变，如更改文档根元素的字体尺寸，则会触发整个文档的重新布局和重绘，据此及上文所述，推荐以下优化和实践： 1.HTML文档结构层次尽量少，最好不深于六层； 2.脚本尽量后放，放在前即可； 3.少量首屏样式内联放在标签内； 4.样式结构层次尽量简单； 5.在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流； 6.减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画； 7.动画尽量使用在绝对定位或固定定位的元素上； 8.隐藏在屏幕外，或在页面滚动时，尽量停止动画； 9.尽量缓存DOM查找，查找器尽量简洁； 10.涉及多域名的网站，可以开启域名预解析实例 当我们访问一个页面时，浏览器渲染事件详细日志图如下： 1.发起请求； 2.解析HTML； 3.解析样式； 4.执行JavaScript； 5.布局；","categories":[],"tags":[]},{"title":"前端性能优化","slug":"前端性能优化","date":"2017-05-09T09:37:37.000Z","updated":"2017-05-09T09:48:29.514Z","comments":true,"path":"2017/05/09/前端性能优化/","link":"","permalink":"http://yoursite.com/2017/05/09/前端性能优化/","excerpt":"前端性能优化是个巨大的课题，如果要面面俱到的说的话，估计三天三夜说不完。所以我们就从实际的工程应用角度出发，聊我们最常遇见的前端优化问题。","text":"前端性能优化是个巨大的课题，如果要面面俱到的说的话，估计三天三夜说不完。所以我们就从实际的工程应用角度出发，聊我们最常遇见的前端优化问题。 Yslow是雅虎开发的基于网页性能分析浏览器插件，可以检测出网页的具体性能值，并且有著名的Yslow 23条优化规则，这23条，就够我们玩的了。 1. 减少HTTP请求次数尽量合并图片、CSS、JS。比如加载一个页面，如果有5个css文件的话，那么会发出5次http请求，这样会让用户第一次访问你的页面的时候会长时间等待。而如果把这个5个文件合成一个的话，就只需要发出一次http请求，节省网络请求时间，加快页面的加载。 2. 使用CDN网站上静态资源即css、js全都使用cdn分发，图片亦然。 3. 避免空的src和href当link标签的href属性为空、script标签的src属性为空的时候，浏览器渲染的时候会把当前页面的URL作为它们的属性值，从而把页面的内容加载进来作为它们的值。所以要避免犯这样的疏忽。 4. 为文件头指定ExpiresExipres是用来设置文件的过期时间的，一般对css、js、图片资源有效。 他可以使内容具有缓存性，这样下回再访问同样的资源时就通过浏览器缓存区读取，不需要再发出http请求。如下例子： 新浪微博的这个css文件的Expires时间是2016-5-04 09:14:14. 5. 使用gzip压缩内容gzip能够压缩任何一个文本类型的响应，包括html，xml，json。大大缩小请求返回的数据量。 6. 把CSS放到顶部网页上的资源加载时从上网下顺序加载的，所以css放在页面的顶部能够优先渲染页面，让用户感觉页面加载很快。 7. 把JS放到底部加载js时会对后续的资源造成阻塞，必须得等js加载完才去加载后续的文件 ，所以就把js放在页面底部最后加载。 8. 避免使用CSS表达式举个css表达式的例子 font-color: expression( (new Date()).getHours()%3 ? “#FFFFFF” : “#AAAAAA” );这个表达式会持续的在页面上计算样式，影响页面的性能。并且css表达式只被IE支持。 9. 将CSS和JS放到外部文件中目的是缓存文件，可以参考原则4。 但有时候为了减少请求，也会直接写到页面里，需根据PV和IP的比例权衡。 10. 权衡DNS查找次数减少主机名可以节省响应时间。但同时，需要注意，减少主机会减少页面中并行下载的数量。IE浏览器在同一时刻只能从同一域名下载两个文件。当在一个页面显示多张图片时，IE 用户的图片下载速度就会受到影响。所以新浪会搞N个二级域名来放图片。下面是新浪微博的图片域名，我们可以看到他有多个域名，这样可以保证这些不同域名能够同时去下载图片，而不用排队。不过如果当使用的域名过多时，响应时间就会慢，因为不用响应域名时间不一致。 11. 精简CSS和JS这里就涉及到css和js的压缩了。比如下面的新浪的一个css文件，把空格回车全部去掉，减少文件的大小。现在的压缩工具有很多，基本主流的前端构建工具都能进行css和js文件的压缩，如grunt，glup等。 12. 避免跳转有种现象会比较坑爹，看起来没什么差别，其实多次了一次页面跳转。比如当URL本该有斜杠（/）却被忽略掉时。例如，当我们要访问 baidu.com 时，实际上返回的是一个包含301代码的跳转，它指向的是 baidu.com/（注意末尾的斜杠）。在nginx服务器可以使用rewrite；Apache服务器中可以使用Alias 或者 mod_rewrite或者the DirectorySlash来避免。另一种是不用域名之间的跳转， 比如访问 baidu.com/bbs 跳转到bbs.baidu.com/。那么可以通过使用Alias或者mod_rewirte建立CNAME（保存一个域名和另外一个域名之间关系的DNS记录）来替代。 13. 删除重复的JS和CSS重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。 14. 配置ETags它用来判断浏览器缓存里的元素是否和原来服务器上的一致。比last-modified date更具有弹性，例如某个文件在1秒内修改了10次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载 15. 可缓存的AJAX异步请求同样的造成用户等待，所以使用ajax请求时，要主动告诉浏览器如果该请求有缓存就去请求缓存内容。如下代码片段, cache:true就是显式的要求如果当前请求有缓存的话，直接使用缓存 123456$.ajax(&#123; url : &apos;url&apos;, dataType : &quot;json&quot;, cache: true, success : function(son, status)&#123; &#125; 16. 使用GET来完成AJAX请求当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。因此使用GET获取数据时更加有意义。 17. 减少DOM元素数量这是一门大学问，这里可以引申出一堆优化的细节。想要具体研究的可以看后面推荐书籍。总之大原则减少DOM数量，就会减少浏览器的解析负担。 18. 避免404比如外链的css或者js文件出现问题返回404时，会破坏浏览器对文件的并行加载。并且浏览器会把试图在返回的404响应内容中找到可能有用的部分当作JavaScript代码来执行。 19. 减少Cookie的大小Cookie里面别塞那么多东西，因为每个请求都得带着他跑 20. 使用无cookie的域比如CSS、js、图片等，客户端请求静态文件的时候，减少了 Cookie 的反复传输对主域名的影响。 21. 不要使用滤镜IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。 22. 不要在HTML中缩放图片比如你需要的图片尺寸是50* 50 &lt;img width=”50″ height=”50″ src=“hahah.jpg” alt=”hahaha” /&gt; 那就不用用一张500*500的大尺寸图片，影响加载 23. 缩小favicon.ico并缓存以上是Yslow的23个优化原则，基本可以涵盖现在前端大部分的性能优化原则了，很多更加geek和精细优化方法都是从这些原则里面延伸出来的。 具体想了解更多优化细则的童鞋建议去看看下面的一本书，毕竟页数多讲的也细嘛：《高性能网站建设指南（第二版）》，这里面其实就是细化的讲解了上面的23原则。","categories":[],"tags":[]},{"title":"瀑布流特效","slug":"瀑布流特效","date":"2017-05-09T08:01:51.000Z","updated":"2017-05-09T08:20:13.363Z","comments":true,"path":"2017/05/09/瀑布流特效/","link":"","permalink":"http://yoursite.com/2017/05/09/瀑布流特效/","excerpt":"HTML结构","text":"HTML结构 12345678910111213141516171819202122&lt;div id=&quot;main&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;pic&quot;&gt;images/0.jpg&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;pic&quot;&gt;images/1.jpg&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;pic&quot;&gt;images/2.jpg&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;pic&quot;&gt;images/3.jpg&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;pic&quot;&gt;images/4.jpg&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;pic&quot;&gt;images/5.jpg&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;pic&quot;&gt;images/6.jpg&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;pic&quot;&gt;images/7.jpg&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;pic&quot;&gt;images/8.jpg&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;pic&quot;&gt;images/9.jpg&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;pic&quot;&gt;images/10.jpg&lt;/div&gt;&lt;/div&gt; // 省略好多张图片 &lt;!-- 引入Js文件 --&gt; &lt;!-- 通常在body里面引入比较好 不会造成页面加载超载 --&gt; &lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/Scroll.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/Underscore-min.js&quot;&gt;&lt;/script&gt;&lt;/div&gt; CSS样式123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; * &#123; margin: 0; padding: 0; border: 0; &#125; img &#123; vertical-align: top; &#125; body, html &#123; width: 100%; height: 100%; &#125; #main &#123; position: relative; &#125; .box &#123; padding: 15px 0 0 15px; float: left; &#125; .pic &#123; padding: 10px; border: 1px solid #ccc; border-radius: 5px; background-color: #fff; &#125; .pic img &#123; width: 165px; &#125;&lt;/style&gt; JS代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133window.onload = function () &#123; // 1.实现瀑布流布局 waterFall(&apos;main&apos;, &apos;box&apos;); // 2.滚动加载图片 window.onscroll = function () &#123; // 2.1 判断是否加载图片 if (checkWillLoadNewImage()) &#123; // 2.2 造数据 var dataArr = [ &#123;src: &apos;12.jpg&apos;&#125;, &#123;src: &apos;32.jpg&apos;&#125;, &#123;src: &apos;15.jpg&apos;&#125;, &#123;src: &apos;23.jpg&apos;&#125;, &#123;src: &apos;15.jpg&apos;&#125;, &#123;src: &apos;34.jpg&apos;&#125;, &#123;src: &apos;24.jpg&apos;&#125;, &#123;src: &apos;13.jpg&apos;&#125;, &#123;src: &apos;25.jpg&apos;&#125; ]; // 2.3 根据数据创建盒子 for (var i = 0; i &lt; dataArr.length; i++) &#123; var newBox = document.createElement(&apos;div&apos;); newBox.setAttribute(&apos;class&apos;, &apos;box&apos;); $(&apos;main&apos;).appendChild(newBox); var newPic = document.createElement(&apos;div&apos;); newPic.setAttribute(&apos;class&apos;, &apos;pic&apos;); newBox.appendChild(newPic); var newImg = document.createElement(&apos;img&apos;); newPic.appendChild(newImg); newImg.src = &apos;images/&apos; + dataArr[i].src; &#125; // 2.4 重新调用瀑布流布局 waterFall(&apos;main&apos;, &apos;box&apos;); &#125; &#125;&#125;/** 函数调用1 * 实现瀑布流布局 * @param parent 父盒子ID * @param child 子盒子Class */function waterFall(parent, child) &#123; // -- 父盒子居中 -- // 1. 获取所有的盒子 var allBox = $(parent).getElementsByClassName(child); // 2. 获取盒子的宽度 var boxWidth = allBox[0].offsetWidth; // 3. 获取屏幕的宽度 var clientW = document.documentElement.clientWidth || document.body.clientWidth; // 4. 求出列数 var cols = parseInt(clientW / boxWidth); // 5. 赋值给父盒子 然后居中 $(parent).style.width = cols * boxWidth + &apos;px&apos;; $(parent).style.margin = &apos;0 auto&apos;; // -- 子盒子定位 -- // 1. 定义数组 var heightArr = [], boxHeight = 0, minBoxHeight = 0, minBoxIndex = 0; // 2. 遍历盒子 for (var i = 0; i &lt; allBox.length; i++) &#123; // 3. 取出盒子的高度 boxHeight = allBox[i].offsetHeight; // 4. 把盒子添加进数组 if (i &lt; cols) &#123; heightArr.push(boxHeight); &#125; // 4.1 剩余其他的盒子 else &#123; // 4.1.1 求出最小盒子的高度 minBoxHeight = Math.min.apply(null, heightArr); // 4.1.2 求出最小盒子的索引号 minBoxIndex = getMinBoxIndex(heightArr, minBoxHeight); // 4.1.2 子盒子定位 allBox[i].style.position = &apos;absolute&apos;; allBox[i].style.left = minBoxIndex * boxWidth + &apos;px&apos;; allBox[i].style.top = minBoxHeight + &apos;px&apos;; // 更新高度 heightArr[minBoxIndex] += boxHeight; &#125; &#125;&#125;/** 函数调用2 * 最小索引 * @param arr 数组 * @param val 索引值 * @returns &#123;返回索引值&#125; */function getMinBoxIndex(arr, val) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] == val) &#123; return i; &#125; &#125;&#125;/** 函数调用3 * 判断是否加载图片 */function checkWillLoadNewImage() &#123; // 1.获取所有的盒子 var allBox = $(&apos;main&apos;).getElementsByClassName(&apos;box&apos;); // 2.得到最后一个盒子 var lastBox = allBox[allBox.length - 1]; // 3.求出最后一个盒子高度的一半 + 头部偏离的高度 var lastBoxDis = lastBox.offsetWidth * 0.5 + lastBox.offsetTop; // 4.求出屏幕的高度 var screenH = document.documentElement.clientHeight || document.body.clientHeight; // 5. 求出页面偏离头部的距离 var scrollTop = scroll().top; // console.log(lastBoxDis, screenH, scrollTop); 开发中时时进行打印检测 防止错误bug return lastBoxDis &lt;= scrollTop + screenH;&#125;","categories":[],"tags":[]},{"title":"理解HTML语义化","slug":"理解HTML语义化","date":"2015-11-03T06:59:14.000Z","updated":"2017-05-09T07:08:07.966Z","comments":true,"path":"2015/11/03/理解HTML语义化/","link":"","permalink":"http://yoursite.com/2015/11/03/理解HTML语义化/","excerpt":"1、什么是HTML语义化？ 基本上都是围绕着几个主要的标签，像标题（H1~H6）、列表（li）、强调（strong em）等等 根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。","text":"1、什么是HTML语义化？ 基本上都是围绕着几个主要的标签，像标题（H1~H6）、列表（li）、强调（strong em）等等 根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 2、为什么要语义化？ 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看； 用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用； 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 3、写HTML代码时应注意什么？• 尽可能少的使用无语义的标签div和span； • 在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； • 不要使用纯样式标签，如：b、font、u等，改用css设置。 • 需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）； • 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； • 表单域要用fieldset标签包起来，并用legend标签说明表单的用途； • 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。 4、HTML5新增了哪些语义标签，详述之。 见这位大拿的blog","categories":[],"tags":[]},{"title":"三大家族","slug":"三大家族","date":"2014-09-13T02:48:36.000Z","updated":"2017-05-09T09:48:31.773Z","comments":true,"path":"2014/09/13/三大家族/","link":"","permalink":"http://yoursite.com/2014/09/13/三大家族/","excerpt":"offset家族特点 只能取值，不能设置值 获取的结果是数值，不是字符 获取的时候不需要style","text":"offset家族特点 只能取值，不能设置值 获取的结果是数值，不是字符 获取的时候不需要style 网页可见区域宽： document.body.clientWidth; 网页可见区域高： document.body.clientHeight; 网页可见区域宽： document.body.offsetWidth (包括边线的宽); 网页可见区域高： document.body.offsetHeight (包括边线的宽); 网页正文全文宽： document.body.scrollWidth; 网页正文全文高： document.body.scrollHeight; 网页被卷去的高： document.body.scrollTop; 网页被卷去的左： document.body.scrollLeft; offsetWidth 和 offsetHeight 获取对象自身的宽度和高度 ，包括内容、边框和内边距，即：offsetWidth = width + border + padding 123div&#123; width: 300px; border-right:2px solid #ccc; padding:10px;&#125; 注意：和 div.style.width 的区别，其只能获取到行内的数值 offsetLeft 和 offsetTop 距离第一个有定位的父级盒子左边和上边的距离 父级盒子必须要有定位，如果没有，则最终以body为准！ offsetLeft 从父亲的padding开始算 父亲的border不算.即：从子盒子边框到定位父盒子边框的距离。 —————– scroll ———————scroll家族基本概念 网页正文全文宽： document.body.scrollWidth; 网页正文全文高： document.body.scrollHeight; 网页被卷去的高： document.body.scrollTop; 网页被卷去的左： document.body.scrollLeft; 在实际开发中使用比较多的就是scrollTop，如下图： 处理scroll家族浏览器适配问题 ie9+ 和 最新浏览器 window.pageXOffset; （scrollLeft） window.pageYOffset; （scrollTop） Firefox浏览器 和 其他浏览器 document.documentElement.scrollTop; Chrome浏览器 和 没有声明 DTD document.body.scrollTop; 兼容写法 1234var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0; var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0; scrollTo(x,y) 把内容滚动到指定的坐标 格式：scrollTo(xpos,ypos) xpos 必需；要在窗口文档显示区左上角显示的文档的 x 坐标； ypos 必需；要在窗口文档显示区左上角显示的文档的 y 坐标 。 网页大部分都没有水平滚动条，所以，这个x 不太常用。 —————– client ———————client家族1.1 clientWidth和clientHeight 网页可见区域宽： document.body.clientWidth; 网页可见区域高： document.body.clientHeight; 1.2 clientLeft和clientTop clientLeft，clientTop 返回的是元素边框的borderWidth， 如果不指定一个边框或者不定位改元素，其值就为0 1.3 offset、client和scroll的区别分析 left和top分析： clientLeft: 左边边框的宽度；clientTop: 上边边框的宽度 offsetLeft: 当前元素距离有定位的父盒子左边的距离；offsetTop: 当前元素距离有定位的父盒子上边的距离 scrollLeft: 左边滚动的长度; scrollTop: 上边滚动的长度; width和height分析 clientWidth\\/Height: 内容 + 内边距 offsetWidth\\/Height: 内容 + 内边距 + 边框 scrollWidth\\/Height: 滚动内容的宽度和高度","categories":[],"tags":[]},{"title":"使用hexo+git搭建免费个人博客详细教程","slug":"使用hexo-git搭建免费个人博客详细教程","date":"2014-09-12T02:49:00.000Z","updated":"2017-05-09T02:18:57.882Z","comments":true,"path":"2014/09/12/使用hexo-git搭建免费个人博客详细教程/","link":"","permalink":"http://yoursite.com/2014/09/12/使用hexo-git搭建免费个人博客详细教程/","excerpt":"前言使用github pages服务搭建博客的好处有： 1.全是静态文件，访问速度快； 2.免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 3.可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 4.数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 5.博客内容可以轻松打包、转移、发布到其它平台等等；","text":"前言使用github pages服务搭建博客的好处有： 1.全是静态文件，访问速度快； 2.免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 3.可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 4.数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 5.博客内容可以轻松打包、转移、发布到其它平台等等； 准备工作在开始一切之前，你必须已经： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了git for windows（或者其它git客户端） 搭建github博客创建仓库新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 1. 注册的邮箱一定要验证，否则不会成功； 2. 仓库名字必须是：username.github.io，其中username是你的用户名； 3. 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 绑定域名当然，你不绑定域名肯定也是可以的，就用默认的 xxx.github.io 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。 首先你要注册一个域名，域名注册以前总是推荐去godaddy，现在觉得其实国内的阿里云也挺不错的，价格也不贵，毕竟是大公司，放心！ 绑定域名分2种情况：带www和不带www的。 域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问，如下： 然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试： 如果你填写的是没有www的，比如 mygit.me，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://mygit.me 如果你填写的是带www的，比如 www.mygit.me ，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://www.mygit.me 如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 http://abc.mygit.me 没问题，但是访问 http://mygit.me ，不会自动跳转到 http://abc.mygit.me 另外说一句，在你绑定了新域名之后，原来的你的用户名.github.io并没有失效，而是会自动跳转到你的新域名。 配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 $ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 ssh-keygen -t rsa -C &quot;邮件地址&quot; 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 将刚复制的内容粘贴到key那里，title随便填，保存 测试是否成功$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi liuxianan! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 此时你还需要配置： $ git config --global user.name &quot;liuxianan&quot;// 你的github用户名，非昵称$ git config --global user.email &quot;xxx@qq.com&quot;// 填写你的github注册邮箱 使用hexo写博客原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 注意事项 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； 安装$ npm install -g hexo 初始化在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是F:\\Workspaces\\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 $ cd /f/Workspaces/hexo/ $ hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： $ hexo g # 生成 $ hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的： hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章： http://blog.liuxianan.com/windows-port-bind.html 第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑. 修改主题既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 官方主题。 个人比较喜欢的2个主题：hexo-theme-jekyll 和 hexo-theme-yilia。 首先下载这个主题： $ cd /f/Workspaces/hexo/$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 上传到github如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。 首先，ssh key肯定要配置好。 其次，配置_config.yml中有关deploy的部分： 正确写法： deploy: type: git repository: git@github.com:liuxianan/liuxianan.github.io.git branch: master 后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行hexo d的话一般会报如下错误： Deployer not found: github 或者 Deployer not found: git 原因是还需要安装一个插件： npm install hexo-deployer-git --save 打开你的git bash，输入hexo d就会将本次有改动的代码全部提交 写博客定位到我们的hexo根目录，执行命令： hexo new &#39;my-first-blog&#39; hexo会帮我们在_posts下生成相关md文件. 我们只需要打开这个文件就可以开始写博客了. 当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。 注：此文章全文转载自以下链接，仅用于测试个人博客效果。http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html","categories":[],"tags":[]}]}